# 贪心

说实话贪心算法并没有固定的套路，所以唯一的难点就是如何通过局部最优，推出整体最优。

如何能看出从局部最优推到整体最优呢，靠手动模拟，如果模拟可行，那么就试试贪心，不然就可能要用动态规划。

刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。



#### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

大饼干既可以满足小孩子也可以满足大孩子，由于一人只能吃一个，所以大饼干优先分给大孩子。

本题的局部思想就是：先用大饼干喂饱大孩子，充分利用饼干尺寸



#### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

先按排序，然后从头开始将非正数取反，如果所有的非正数都取反了，k还不为0，那么再次排序，根据k的奇偶再对一个元素进行操作。



#### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

- 收十块找五块，没有五块就为false
- 收二十找（十块，五块）或者（三个五块），没有就返回false





#### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png" alt="376.摆动序列" style="zoom:67%;" />

局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。

整体最优：整个序列有最多的**局部峰值**，从而达到最长摆动序列。



看峰值很简单：

​	大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果`prediff < 0 && curdiff > 0` 或者 `prediff > 0 && curdiff < 0` 此时就是一个峰值。

有三种情况需要考虑：

1. **上下坡中有平坡**

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230106172613.png" alt="img" style="zoom:67%;" />

像图示的这个数列，最后的count应该是3。

策略就是忽略平坡的前面几个，只看最后一个，此时的情况是(pre = 0, next < 0)

因而在原来的(pre > 0, next < 0)上补充这个情况，最后完善为：（pre >= 0, next < 0）

因为是忽略前面的只看最后一个，所以等号在pre上

形如：{2，1，1，1，2}的也是如此，在pre上加=

最后判断条件为：**(pre >= 0,  next < 0) || (pre <= 0, next > 0)**

2. **数组前后两端有相同的**

假设在一个首部没有重复元素的数组上加上一个数字，如{2，2，5}

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174357612.png" alt="376.摆动序列1" style="zoom:67%;"/>

在1中讨论了存在平坡的情况，那么如何使得规则能够统一呢

首先定义pre = 0，res = 1，res记录的是在整个山谷图上有多少个结点，初始化为1是因为最右边元素必定是山谷的一部分（1中策略，一样只看最右边），就算所有的元素都一样，那么前面的都忽略，相当于只有最后一个元素。

3. **单调坡度有平坡**

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png" alt="img" style="zoom:67%;" />

因为res初始化为1，在图中的第一个2和第三个2都会进行res++，实际上结果是2

这是因为单调平坡不算峰值，即第三个2不应该算山谷

这就要求pre只有在坡度进行摆动变化的时候才进行更新

具体过程：

​	在遍历第一个2的时候，判断条件进行生效，res++。此时pre从0变为1

​	在遍历第二个2的时候，next = 0，跳过

​	在遍历第三个2的时候，(pre = 1, next = 1)，不满足判断条件，继续遍历

​	在遍历到3的时候，(pre = 1, next = 1)，不满足判断条件，for循环也遍历完了，结束。





#### [单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

核心思路：

​	例如：98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），

​	首先想让**strNum[i - 1]--，然后 strNum[i] 以及后给为9**，这样这个整数就是89，即小于98的最大的单调递增整数。



遍历顺序：从后往前。

如果从前往后的话，举个例子332，最后结果是329，正确结果应该是299

从后往前的话：332 -> 329 -> 299

​			   3133 -> 3099 -> 2999



#### [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

本题只有一只股票，且至少要两天才能完成一个交易周期

核心思路就是选择一个低的买入，然后高的卖出，循环往复，也就是说最终利润是可以分解的

比如第0天买入，第3天卖出，那么利润就是：prices[3] - prices[0]

也就相当于：(prices[1] - prices[0]) + (prices[2] - prices[1]) + (prices[3] - prices[2]) 

第0天卖第1天买 + 第1天买第2天卖 + .....  

把利润分解成每天的维度

```
prices = {7，1，5，10，3，6，4}
profits = {-6，4，5，-7，3，1}
```

我们只要收集正利润的区间，累加求和即可



#### [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

1. 子数组开始一定是从整数开始，如果开头是负数的话，纯有毛病.....

2. 局部最优：当连续和为负数时，立刻放弃，**从一个元素**开始重新计算连续和

   全局最优：选取最大连续和

   ```
   关于局部最优的解释
   假设{9, b, c, d, e, f, g}
   如果子数组和计算到c还是大于0，计算到d小于0了，那么可以肯定d一定小于0
   
   {9, b, c, -4, e, f, g}
   那么存不存在{b, c, -4} 或者{c, -4}还为正呢，那么这就可以做接下来的开头嘛
   
   已知: 9 + b + c + -4 < 0
   那么:b + c + -4 < 0，第一个假设不成立
   
   再假设:c + -4 > 0,
   那么 9 + b < 0，也就不存在子数组和计算到c了，直接从c开始从新计算了，第二个假设也不成立
   
   由此可知：不存在{b, c, -4} 或者{c, -4}还为正的情况
   因此直接重置count，从下一个元素直接开始重新计算。
   ```







#### [跳跃游戏](https://leetcode.cn/problems/jump-game/)

不用纠结于到底走几步，比如nums[0] = 3，那么一开始可以走1，2，3步，不用纠结这个

关键是看可跳的范围，一旦可跳跃的范围囊括到了最后一个，就成功

所以便利的过程实际上就是不断调整覆盖范围cover的过程

每次移动取最大步数 

注意：i 只能再cover内移动，每次移动cover取MAX（cover，该元素数组补充后的范围）



#### [跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

这题与上一题的区别就是求的是最少跳跃步数

思路类型，还是看最大覆盖范围

从覆盖范围出发，不管怎么样挑，覆盖范围是一定可以跳到的，**以最小的步数增加覆盖范围**，一旦覆盖范围覆盖到了终点，就得到了最少步数

要统计两个覆盖范围：当前最大覆盖 和 下一步最大覆盖

1. 如果**移动下标达到了当前这一步的最大覆盖最远距离**，但还是没有到达终点，那么就必须再走一步来更新覆盖范围，这个覆盖范围就是下一步最大覆盖
2. 下一步覆盖范围：以当前最大覆盖范围内的点作为起点，分别计算覆盖范围，取其中最大的



#### [加油站](https://leetcode.cn/problems/gas-station/)

如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站剩油量rest[i]相加一定是大于等于零的。（这是前提）

每个加油站的剩余量rest[i]为gas[i] - cost[i]



i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，那么起始位置从i+1算起，再从0计算curSum。

因为这个区间选择任何一个位置作为起点，到i这里都会断油，

```
1️⃣为什么就是直接从i + 1 下标开始呢？为什么就不能在[0, i]之间开始的呢？
{[区间和a],[区间和b]}
如果总区间和小于0了，那么就是a + b < 0
假设区间和 b > 0, 那么 a < 0
那么区间和a算完之后，就直接从后面开始从新计算了

2️⃣为什么可以是 i + 1 呢？后面会不会有更大的负数
如果出现更大的负数，起始位置又变成i + 1 了，所以无所谓
```

局部最优：**当前累加 rest[i] 的和一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。**



#### [用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

为了让气球尽可能地重叠，先将气球以左边界（右边界也行）的大小排序，然后当出现重叠的时候一起射

具体操作是：重叠气球中右边边界的最小值之前的区间一定需要一个弓箭

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791.png" alt="452.用最少数量的箭引爆气球" style="zoom:67%;" />



#### [无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

1️⃣记录重叠区间数

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png" alt="img" style="zoom: 67%;" />

图中为按右边界排序

当我们确定区间1，2重叠后，如何判断区间3是否也重叠呢

就取区间1，2的最小右边界，如果区间3的左边界 小于 它，那么就是重叠，相应的更新最小右边界以及count



2️⃣类似射箭，只是把重叠判断条件改了一下，箭的个数就是**非重叠区间**的个数



#### [合并区间](https://leetcode.cn/problems/merge-intervals/)

类似的套路，都是判断区间重叠，区别是操作逻辑，本题是将重叠的区间进行合并



#### [划分字母区间](https://leetcode.cn/problems/partition-labels/)

题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？

在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。

- 统计每个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现下标和当前下标相等了，那就是分割点。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png" alt="763.划分字母区间" style="zoom:67%;" />





#### [根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

两个维度：(身高h，前面大于等于它身高的人数k)

动中有静，两个维度一起考虑肯定会顾此失彼，必须先确定一个在确定另一个

如果按照从小到大排，那么排列的结果肯定是不符合条件的，两个维度一个都确定不下来

那么就是先身高，从小到大进行排序

```
people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
```

第一轮排序结果为：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216201851982.png" alt="406.根据身高重建队列" style="zoom:67%;" />

接下来从前往后遍历，就以k为下标，直接插入就行了

原因：

以(5, 2)为例，(5, 2)前面的一定比(5, 2)高，那么直接插入到下标2的位置，直接就可以确定它前面一定有比它高两个的元素









